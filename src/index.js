/*
 * @file: fix empty js bundle generated by mini-css-extract-plugin when using splitchunks
 * @author: gaoyang.lamb
 * @date: 2020 06 12 15:05:12
 */
'use strict';

const path = require('path');

const CSS_MODULE_TYPE = 'css/mini-extract';

const pluginName = 'mini-css-extract-useless-js-plugin';

module.exports = class MiniCssExtractUselessJsPlugin {
  constructor(options) {
    this.problemChunkInfos = {};
  }
  apply(compiler) {
    compiler.hooks.thisCompilation.tap(pluginName, compilation => {
      compilation.hooks.beforeChunkAssets.tap(pluginName, () => {
        // 找到所有由 splitchunks 优化导致产生的 chunk
        const splitChunks = compilation.chunks.filter(
          thisChunk => thisChunk.chunkReason && thisChunk.chunkReason.includes('split chunk')
        );

        splitChunks.forEach(splitChunk => {
          // 存储空 JS module
          const uselessModules = [];
          // 存储不是 CssModule 的模块
          const noCssModules = [];
          // 存储 CssModule 模块
          const cssModules = [];
          Array.from(splitChunk.modulesIterable).forEach(mod => {
            if (mod.type !== CSS_MODULE_TYPE) {
              noCssModules.push(mod);
            } else {
              cssModules.push(mod);
            }
          });

          noCssModules.forEach(nonCssMod => {
            if (nonCssMod._source && nonCssMod._source._value === '// extracted by mini-css-extract-plugin') {
              uselessModules.push(nonCssMod);
            }
          });

          // 处理 『问题 chunk』
          if (uselessModules.length === noCssModules.length) {
            const problemChunkId = splitChunk.id;
            const problemChunkInfo = {
              id: problemChunkId,
              originChunks: [],
            };
            // 把『问题 chunk』中所有 JS module 移动到 『源 chunk』
            uselessModules.forEach(uselessModule => {
              uselessModule.reasons.forEach(reason => {
                reason.module.chunksIterable.forEach(previouslyConnectedChunk => {
                  splitChunk.moveModule(uselessModule, previouslyConnectedChunk);
                });
              });
            });

            // 记录当前 『问题 chunk』的 CssModule 与 『源 chunk』 的关系，以在后续 additionalChunkAssets 阶段使用
            cssModules.forEach(cssModule => {
              cssModule.reasons.forEach(cssModuleReason => {
                cssModuleReason.module.reasons.forEach(uselessModuleReason => {
                  uselessModuleReason.module.chunksIterable.forEach(originChunk => {
                    problemChunkInfo.originChunks.push(originChunk);
                  });
                });
              });
            });

            this.problemChunkInfos[problemChunkId] = problemChunkInfo;

            // 入口 chunkGroup 中删掉对 『问题 chunk』的依赖
            splitChunk.groupsIterable.forEach(group => {
              group.removeChunk(splitChunk);
            });
          }
        });
      });

      compilation.hooks.additionalChunkAssets.tap(pluginName, chunks => {
        chunks.forEach(chunk => {
          // problemChunkInfos 存储了所有的『问题 chunk』
          if (this.problemChunkInfos[chunk.id]) {
            chunk.files.forEach(file => {
              if (path.extname(file) === '.css') {
                this.problemChunkInfos[chunk.id].originChunks.forEach(originChunk => {
                  // 把『问题 chunk』中生成的 css 文件注入到入口 files 依赖中
                  // html-webpack-plugin 生成 html 时会去解析这里的依赖，从而自动生成对 css 文件的 link 引用标签。
                  originChunk.files.push(file);
                });
              } else if (path.extname(file) === '.js') {
                // 阻止『问题 chunk』对空 js 文件的生成
                chunk.files.pop();
                delete compilation.assets[file];
              }
            });
          }
        });
      });
    });
  }
};
